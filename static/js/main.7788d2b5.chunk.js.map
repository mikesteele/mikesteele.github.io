{"version":3,"sources":["Image.js","useInterval.js","index.js"],"names":["Image","url","texture","opacity","scale","useMemo","THREE","load","attach","object","useInterval","Thing","props","previousShape","shape","cube1Ref","useRef","useFrame","current","rotation","y","x","from","xScale","zScale","zPosition","xRotation","to","ref","position","args","color","wireframe","ReactDOM","render","React","useState","shapes","setShapes","href","className","onMouseOver","e","onMouseOut","camera","intensity","angle","penumbra","castShadow","document","getElementById"],"mappings":"qQAgBeA,MAVf,YAAmD,IAAlCC,EAAiC,EAAjCA,IAETC,GAF0C,EAA5BC,QAA4B,EAAnBC,MAAmB,yCAEhCC,mBAAQ,kBAAM,IAAIC,KAAsBC,KAAKN,KAAM,CAACA,KACpE,OACE,yCAAqBO,OAAO,WAAWL,QAAS,IAC9C,+BAAWK,OAAO,MAAMC,OAAQP,MCWvBQ,I,QC0Ff,SAASC,EAAMC,GACoBA,EAAzBC,cADa,IACEC,EAAUF,EAAVE,MACjBC,EAAWC,mBAiCjBC,aAAS,WACO,SAAVH,IACFC,EAASG,QAAQC,SAASC,EAAIL,EAASG,QAAQC,SAASC,EAAI,IAC5DL,EAASG,QAAQC,SAASE,EAAIN,EAASG,QAAQC,SAASE,EAAI,QAKhE,OACE,kBAAC,SAAD,CACEC,KAAM,CACJC,OAAkB,SAAVT,EAAmB,IAAM,EACjCU,OAAkB,SAAVV,EAAmB,GAAM,EACjCW,UAAqB,SAAVX,EAAmB,GAAM,EACpCY,UAAsB,SAAVZ,EAAmB,EAAI,IAErCa,GAAI,CACFJ,OAAkB,SAAVT,EAAmB,EAAI,IAC/BU,OAAkB,SAAVV,EAAmB,EAAI,GAC/BW,UAAqB,SAAVX,EAAmB,EAAI,GAClCY,UAAsB,SAAVZ,EAAmB,GAAM,KAGtC,SAAAF,GAKC,MAHc,SAAVE,GACqBF,EAAMc,UAG7B,0BAAME,IAAKb,EAAUc,SAAU,CAAC,EAAE,EAAEjB,EAAMa,WAAYN,SAAoB,SAAVL,EAAmB,CAAC,EAAE,EAAE,GAAI,CAACF,EAAMc,UAAW,EAAG,IAC/G,uCAAmBlB,OAAO,WAAWsB,KAAM,CAAClB,EAAMW,OAAQ,EAAGX,EAAMY,UACxD,SAAVV,EACC,uCAAmBiB,MAzBhB,QAyB8BC,WAAS,EAACxB,OAAO,aAElD,kBAAC,EAAD,CAAOP,IAAI,WAEb,uCAAmBO,OAAO,WAAWsB,KAAM,CAAClB,EAAMW,OAAQ,EAAGX,EAAMY,cAuD/ES,IAASC,OAAO,mBA9CJ,WAAO,IAAD,EACYC,IAAMC,SAAS,CACzCtB,MAAO,OACPD,cAAe,SAHD,mBACTwB,EADS,KACDC,EADC,KA6BhB,OACE,oCACF,uBAAGC,KAAK,+CACL,yBAAKC,UAAU,QAAQC,YA3BJ,SAAAC,GACpBJ,GAAU,SAAAD,GAAM,MAAK,CACnBxB,cAAewB,EAAOvB,MACtBA,MAAO,UAwB2C6B,WArBjC,SAAAD,GACnBJ,GAAU,SAAAD,GAAM,MAAK,CACnBxB,cAAewB,EAAOvB,MACtBA,MAAO,aAkBR,kBAKC,kBAAC,IAAD,CAAQ8B,OAAQ,CAAEf,SAAU,CAAC,EAAG,EAAG,KACjC,kCAAcgB,UAAW,KACzB,+BAAWA,UAAW,GAAKhB,SAAU,CAAC,GAAI,GAAI,IAAKiB,MAAO,GAAKC,SAAU,EAAGC,YAAU,IACtF,kBAACrC,EAAD,CAAOG,MAAOuB,EAAOvB,MAAOD,cAAewB,EAAOxB,oBAM1C,MAASoC,SAASC,eAAe,W","file":"static/js/main.7788d2b5.chunk.js","sourcesContent":["import ReactDOM from 'react-dom'\nimport * as THREE from 'three/src/Three'\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react'\nimport { apply as applyThree, Canvas, useRender, useThree } from 'react-three-fiber'\n\n/** This component loads an image and projects it onto a plane */\nfunction Image({ url, opacity, scale, ...props }) {\n  //const texture = useMemo(() => new THREE.VideoTexture( document.querySelector('video') ), [url])\n  const texture = useMemo(() => new THREE.TextureLoader().load(url), [url])\n  return (\n    <meshLambertMaterial attach=\"material\" opacity={0.3}>\n      <primitive attach=\"map\" object={texture} />\n    </meshLambertMaterial>\n  )\n}\n\nexport default Image;\n","import React, { useState, useEffect, useRef } from 'react';\n\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n\nexport default useInterval;\n","import React, { useRef, useEffect } from 'react'\nimport ReactDOM from 'react-dom'\nimport { Canvas, useFrame } from 'react-three-fiber'\nimport './index.css';\nimport Image from './Image';\nimport useInterval from './useInterval';\nimport {Spring} from 'react-spring/renderprops'\n\n\n/**\nconst useSpring = (toValue, oldValue, frameCount) => {\n  const lastValue = useRef();\n  const springAmount = Math.abs((toValue - oldValue)) / frameCount;\n  useFrame(() => {\n    if (lastValue.current) {\n      if (lastValue.current === toValue) {\n        // No-op\n      } else if (Math.abs(lastValue.current - toValue) <= springAmount) {\n        lastValue.current = toValue\n      } else if (lastValue.current < toValue) {\n        lastValue.current = lastValue.current + springAmount\n      } else if (lastValue.current > toValue) {\n        lastValue.current = lastValue.current - springAmount\n      }\n    } else {\n      lastValue.current = oldValue;\n    }\n  });\n  return lastValue.current;\n}\n*/\n\nconst useSpringYPosition = (ref, toValue, springAmount) => {\n  useFrame(() => {\n    if (ref.current) {\n      if (ref.current.position.y === toValue) {\n        return\n      } else if (Math.abs(ref.current.position.y - toValue) <= springAmount) {\n        ref.current.position.y = toValue\n      } else if (ref.current.position.y < toValue) {\n        ref.current.position.y = ref.current.position.y + springAmount\n      } else if (ref.current.position.y > toValue) {\n        ref.current.position.y = ref.current.position.y - springAmount\n      }\n    }\n  })\n}\n\nconst useSpringXScale = (ref, toValue, springAmount) => {\n  useFrame(() => {\n    if (ref.current) {\n      if (ref.current.scale.x === toValue) {\n        return\n      } else if (Math.abs(ref.current.scale.x - toValue) <= springAmount) {\n        ref.current.scale.x = toValue\n      } else if (ref.current.scale.x < toValue) {\n        ref.current.scale.x = ref.current.scale.x + springAmount\n      } else if (ref.current.scale.x > toValue) {\n        ref.current.scale.x = ref.current.scale.x - springAmount\n      }\n    }\n  })\n}\n\nconst useSpringYScale = (ref, toValue, springAmount) => {\n  useFrame(() => {\n    if (ref.current) {\n      if (ref.current.scale.y === toValue) {\n        return\n      } else if (Math.abs(ref.current.scale.y - toValue) <= springAmount) {\n        ref.current.scale.y = toValue\n      } else if (ref.current.scale.y < toValue) {\n        ref.current.scale.y = ref.current.scale.y + springAmount\n      } else if (ref.current.scale.y > toValue) {\n        ref.current.scale.y = ref.current.scale.y - springAmount\n      }\n    }\n  })\n}\n\n\nconst useSpringXRotation = (ref, toValue, springAmount) => {\n  useFrame(() => {\n    if (ref.current) {\n      if (ref.current.rotation.x === toValue) {\n        return\n      } else if (Math.abs(ref.current.rotation.x - toValue) <= springAmount) {\n        ref.current.rotation.x = toValue\n      } else if (ref.current.rotation.x < toValue) {\n        ref.current.rotation.x = ref.current.rotation.x + springAmount\n      } else if (ref.current.rotation.x > toValue) {\n        ref.current.rotation.x = ref.current.rotation.x - springAmount\n      }\n    }\n  })\n}\n\nconst useSpringZRotation = (ref, toValue, springAmount) => {\n  useFrame(() => {\n    if (ref.current) {\n      if (ref.current.rotation.cube1ZRotation === toValue) {\n        return\n      } else if (Math.abs(ref.current.rotation.z - toValue) <= springAmount) {\n        ref.current.rotation.z = toValue\n      } else if (ref.current.rotation.z < toValue) {\n        ref.current.rotation.z = ref.current.rotation.z + springAmount\n      } else if (ref.current.rotation.z > toValue) {\n        ref.current.rotation.z = ref.current.rotation.z - springAmount\n      }\n    }\n  })\n}\nfunction Thing(props) {\n  const { previousShape, shape } = props\n  const cube1Ref = useRef()\n  const cube1YPosition = {\n    none: 0,\n    cube: 0,\n    dc: 0,\n    resume: 0\n  }\n\n  const cube1XScale = {\n    none: 1,\n    cube: 1,\n    dc: 0.01,\n    resume: 0\n  }\n\n  const cube1YScale = {\n    none: 1,\n    cube: 1,\n    dc: 1,\n    resume: 1\n  }\n\n  const cube1XRotation = {\n    none: 0,\n    cube: 0,\n    dc: 0,\n    resume: 0\n  }\n\n\n  const springAmountForFrameCount = (oldValue, newValue, frameCount) => {\n    return Math.abs((newValue - oldValue)) / frameCount\n  }\n  useFrame(() => {\n    if (shape === 'cube') {\n      cube1Ref.current.rotation.y = cube1Ref.current.rotation.y + 0.01\n      cube1Ref.current.rotation.x = cube1Ref.current.rotation.x + 0.01\n    }\n  });\n\n  const color =  'white';\n  return (\n    <Spring\n      from={{\n        xScale: shape === 'cube' ? 1.8 : 1,\n        zScale: shape === 'cube' ? 0.1 : 1,\n        zPosition: shape === 'cube' ? 0.7 : 0,\n        xRotation:  shape === 'cube' ? 0 : 0.5\n      }}\n      to={{\n        xScale: shape === 'cube' ? 1 : 1.8,\n        zScale: shape === 'cube' ? 1 : 0.1,\n        zPosition: shape === 'cube' ? 0 : 0.7,\n        xRotation:  shape === 'cube' ? 0.5 : 0\n      }}\n    >\n      {props => {\n        const extraProps = {};\n        if (shape !== 'cube') {\n          extraProps.rotation = [props.xRotation, 0, 0];\n        }\n        return (\n          <mesh ref={cube1Ref} position={[0,0,props.zPosition]} rotation={shape === 'cube' ? [0,0,0]: [props.xRotation, 0, 0]}>\n            <boxBufferGeometry attach=\"geometry\" args={[props.xScale, 1, props.zScale]} />\n            {shape === 'cube' ? (\n              <meshPhongMaterial color={color} wireframe attach=\"material\" />\n            ): (\n              <Image url=\"/1.png\" />\n            )}\n            <boxBufferGeometry attach=\"geometry\" args={[props.xScale, 1, props.zScale]} />\n\n          </mesh>\n        )\n      }}\n      </Spring>\n  )\n}\n\nconst App = () => {\n  const [shapes, setShapes] = React.useState({\n    shape: 'cube',\n    previousShape: 'none'\n  });\n  const onMouseOverDC = e => {\n    setShapes(shapes => ({\n      previousShape: shapes.shape,\n      shape: 'dc'\n    }));\n  }\n  const onMouseOutDC = e => {\n    setShapes(shapes => ({\n      previousShape: shapes.shape,\n      shape: 'cube'\n    }));\n  }\n  const onMouseOverResume = e => {\n    setShapes(shapes => ({\n      previousShape: shapes.shape,\n      shape: 'resume'\n    }));\n  }\n  const onMouseOutResume = e => {\n    setShapes(shapes => ({\n      previousShape: shapes.shape,\n      shape: 'cube'\n    }));\n  }\n  return (\n    <>\n  <a href=\"https://github.com/mikesteele/dual-captions\">\n     <div className='links' onMouseOver={onMouseOverDC} onMouseOut={onMouseOutDC}>\n        dual-captions\n      </div>\n      </a>\n\n      <Canvas camera={{ position: [0, 0, 2] }}>\n        <ambientLight intensity={0.5} />\n        <spotLight intensity={0.6} position={[30, 30, 50]} angle={0.2} penumbra={1} castShadow />\n        <Thing shape={shapes.shape} previousShape={shapes.previousShape} />\n      </Canvas>\n    </>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}